{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import {Dictionary, Key, ReadonlyDictionary} from \"dictionary-types\";\n\n/** Creates a new dictionary with the specified properties. */\nexport function dictionary<T, K extends Key = string>(\n    properties?: ReadonlyDictionary<T, K>\n): Dictionary<T, K> {\n    return copy(properties ?? ({} as ReadonlyDictionary<T, K>));\n}\n\n/** Creates a shallow copy of the specified dictionary. */\nexport function copy<T, K extends Key, L extends K = K>(\n    dictionary: ReadonlyDictionary<T, K>\n): Dictionary<T, L> {\n    return Object.assign(Object.create(null), dictionary);\n}\n\n// @ts-ignore duplicate identifier: This is the exported declaration, the implementation is below.\nexport function keys<T extends Key>(dictionary: Readonly<Record<T, unknown>>): string[];\n\n/* @internal This implementation is for internal use only, the exported declaration is above */\n// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.\nexport const keys: <T extends Key>(dictionary: Readonly<Record<T, unknown>>) => string[] =\n    Object.keys;\n\n// @ts-ignore duplicate identifier: This is the exported declaration, the implementation is below.\nexport function values<TKey extends Key, TValue>(\n    dictionary: Readonly<Record<TKey, TValue>>\n): TValue[];\n\n/* @internal This implementation is for internal use only, the exported declaration is above. */\n// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.\nexport const values: <TKey extends Key, TValue>(\n    dictionary: Readonly<Record<TKey, TValue>>\n) => TValue[] = Object.values;\n\n// @ts-ignore duplicate identifier: This is the exported declaration, the implementation is below.\nexport function entries<TKey extends Key, TValue>(\n    dictionary: Readonly<Record<TKey, TValue>>\n): Array<[string, TValue]>;\n\n/* @internal This implementation is for internal use only, the exported declaration is above. */\n// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.\nexport const entries: <TKey extends Key, TValue>(\n    dictionary: Readonly<Record<TKey, TValue>>\n) => Array<[string, TValue]> = Object.entries;\n\nexport function empty<T>(dictionary: ReadonlyDictionary<T>): boolean {\n    return keys(dictionary).length === 0;\n}\n\nexport function merge<T>(...dictionaries: Array<ReadonlyDictionary<T>>): Dictionary<T> {\n    const result: Dictionary<T> = Object.create(null);\n    for (let i = 0; i < dictionaries.length; ++i) {\n        Object.assign(result, dictionaries[i]);\n    }\n    return result;\n}\n\nexport function mergeFn<T>(\n    ...dictionaries: Array<ReadonlyDictionary<T>>\n): (...dictionaries: Array<ReadonlyDictionary<T>>) => Dictionary<T> {\n    const a = merge(...dictionaries);\n    return (...b) => merge(a, ...b);\n}\n\nexport function map<T, U>(\n    dictionary: ReadonlyDictionary<T>,\n    f: (value: T, key: string) => U\n): Dictionary<U> {\n    const result: Dictionary<U> = {};\n    for (const [key, value] of entries(dictionary)) {\n        result[key] = f(value, key);\n    }\n    return result;\n}\n\nexport function mapFn<T, U>(\n    f: (value: T, key: string) => U\n): (dictionary: ReadonlyDictionary<T>) => Dictionary<U> {\n    return dictionary => map(dictionary, f);\n}\n\nexport function filter<T, U extends T>(\n    dictionary: ReadonlyDictionary<T>,\n    predicate: (value: T) => value is U\n): Dictionary<U>;\nexport function filter<T>(\n    dictionary: ReadonlyDictionary<T>,\n    predicate: (value: T, key: string) => boolean\n): Dictionary<T>;\nexport function filter<T>(\n    dictionary: ReadonlyDictionary<T>,\n    predicate: (value: T, key: string) => boolean\n): Dictionary<T> {\n    const result: Dictionary<T> = {};\n    for (const [key, value] of entries(dictionary)) {\n        if (predicate(value, key)) {\n            result[key] = value;\n        }\n    }\n    return result;\n}\n\nexport function filterFn<T, U extends T>(\n    predicate: (value: T) => value is U\n): (dictionary: ReadonlyDictionary<T>) => Dictionary<U>;\nexport function filterFn<T>(\n    predicate: (value: T, key: string) => boolean\n): (dictionary: ReadonlyDictionary<T>) => Dictionary<T>;\nexport function filterFn<T>(\n    predicate: (value: T, key: string) => boolean\n): (dictionary: ReadonlyDictionary<T>) => Dictionary<T> {\n    return dictionary => filter(dictionary, predicate);\n}\n\nexport function excludeNull<T>(\n    dictionary: ReadonlyDictionary<T | undefined | null>\n): Dictionary<T> {\n    return filter(dictionary, notNull);\n}\n\nfunction notNull<T>(value: T | undefined | null): value is T {\n    return value != null;\n}\n\nexport function forEach<T>(\n    dictionary: ReadonlyDictionary<T>,\n    f: (value: T, key: string) => void\n): void {\n    for (const [key, value] of entries(dictionary)) {\n        f(value, key);\n    }\n}\n\nexport function forEachFn<T>(\n    f: (value: T, key: string) => void\n): (dictionary: ReadonlyDictionary<T>) => void {\n    return dictionary => forEach(dictionary, f);\n}\n"]}