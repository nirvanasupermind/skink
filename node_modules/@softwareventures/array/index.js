"use strict";
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.containsFn = exports.contains = exports.foldMapRightFn = exports.foldMapRight = exports.foldMapFn = exports.foldMap = exports.foldRight1Fn = exports.foldRight1 = exports.foldRightFn = exports.foldRight = exports.fold1Fn = exports.fold1 = exports.foldFn = exports.fold = exports.removeFirstFn = exports.removeFirst = exports.removeFn = exports.remove = exports.excludeFirstFn = exports.excludeFirst = exports.excludeNull = exports.excludeFn = exports.exclude = exports.filterFirstFn = exports.filterFirst = exports.filterFn = exports.filter = exports.mapFn = exports.map = exports.dropWhileFn = exports.dropWhile = exports.takeWhileFn = exports.takeWhile = exports.dropFn = exports.drop = exports.takeFn = exports.take = exports.sliceFn = exports.slice = exports.reverse = exports.notEmpty = exports.empty = exports.last = exports.initial = exports.tail = exports.head = exports.coerce = exports.isArrayLike = exports.isArray = exports.copy = void 0;
exports.groupByOrderFn = exports.groupByOrder = exports.groupByEqualityFn = exports.groupByEquality = exports.groupByIdentityFn = exports.groupByIdentity = exports.groupFn = exports.group = exports.keyLastByFn = exports.keyLastBy = exports.keyFirstByFn = exports.keyFirstBy = exports.keyByFn = exports.keyBy = exports.partitionWhileFn = exports.partitionWhile = exports.partitionFn = exports.partition = exports.scanRight1Fn = exports.scanRight1 = exports.scanRightFn = exports.scanRight = exports.scan1Fn = exports.scan1 = exports.scanFn = exports.scan = exports.noneNull = exports.concatMapFn = exports.concatMap = exports.append = exports.prepend = exports.concat = exports.allFn = exports.all = exports.anyFn = exports.any = exports.or = exports.and = exports.product = exports.sum = exports.minimumFn = exports.minimum = exports.maximumFn = exports.maximum = exports.findFn = exports.find = exports.findIndexFn = exports.findIndex = exports.indexOfFn = exports.indexOf = void 0;
exports.forEachFn = exports.forEach = exports.shuffle = exports.uniqueAdjacentByHashFn = exports.uniqueAdjacentByHash = exports.uniqueAdjacentByOrderFn = exports.uniqueAdjacentByOrder = exports.uniqueAdjacentByEqualityFn = exports.uniqueAdjacentByEquality = exports.uniqueAdjacentByIdentityFn = exports.uniqueAdjacentByIdentity = exports.uniqueAdjacentFn = exports.uniqueAdjacent = exports.uniqueByOrderWithHashFn = exports.uniqueByOrderWithHash = exports.uniqueByEqualityWithHashFn = exports.uniqueByEqualityWithHash = exports.uniqueByIdentityWithHashFn = exports.uniqueByIdentityWithHash = exports.uniqueByHashFn = exports.uniqueByHash = exports.uniqueByOrderFn = exports.uniqueByOrder = exports.uniqueByEqualityFn = exports.uniqueByEquality = exports.uniqueByIdentity = exports.uniqueFn = exports.unique = exports.groupAdjacentByHashFn = exports.groupAdjacentByHash = exports.groupAdjacentByOrderFn = exports.groupAdjacentByOrder = exports.groupAdjacentByEqualityFn = exports.groupAdjacentByEquality = exports.groupAdjacentByIdentityFn = exports.groupAdjacentByIdentity = exports.groupAdjacentFn = exports.groupAdjacent = exports.groupByOrderWithHashFn = exports.groupByOrderWithHash = exports.groupByEqualityWithHashFn = exports.groupByEqualityWithHash = exports.groupByIdentityWithHashFn = exports.groupByIdentityWithHash = exports.groupByHashFn = exports.groupByHash = void 0;
var dictionary_1 = require("@softwareventures/dictionary");
var nullable_1 = require("@softwareventures/nullable");
var ordered_1 = require("@softwareventures/ordered");
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeSlice = Array.prototype.slice;
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeConcat = Array.prototype.concat;
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeMap = Array.prototype.map;
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeFilter = Array.prototype.filter;
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeReduce = Array.prototype.reduce;
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeReduceRight = Array.prototype.reduceRight;
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeIndexOf = Array.prototype.indexOf;
// eslint-disable-next-line @typescript-eslint/unbound-method
var nativeFindIndex = Array.prototype.findIndex;
/** @internal This implementation is for internal use only, the exported declaration is above */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.
exports.copy = (_a = Array.from) !== null && _a !== void 0 ? _a : (function (array) { return nativeSlice.call(array); });
// eslint-disable-next-line @typescript-eslint/unbound-method
var toString = Object.prototype.toString;
/** @internal This implementation is for internal use only, the exported declaration is above */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.
exports.isArray = (_b = Array.isArray) !== null && _b !== void 0 ? _b : (function (value) { return toString.call(value) === "[object Array]"; });
function isArrayLike(value) {
    return (typeof value === "object" &&
        value != null &&
        "length" in value &&
        typeof value.length === "number");
}
exports.isArrayLike = isArrayLike;
function coerce(array) {
    return exports.isArray(array) ? array : exports.copy(array);
}
exports.coerce = coerce;
function head(array) {
    return array.length === 0 ? null : array[0];
}
exports.head = head;
function tail(array) {
    return nativeSlice.call(array, 1);
}
exports.tail = tail;
function initial(array) {
    return array.length === 0 ? [] : nativeSlice.call(array, 0, array.length - 1);
}
exports.initial = initial;
function last(array) {
    return array.length === 0 ? null : array[array.length - 1];
}
exports.last = last;
function empty(array) {
    return array.length === 0;
}
exports.empty = empty;
function notEmpty(array) {
    return array.length > 0;
}
exports.notEmpty = notEmpty;
function reverse(array) {
    var result = exports.copy({ length: array.length });
    for (var i = 0; i < array.length; ++i) {
        result[i] = array[array.length - i - 1];
    }
    return result;
}
exports.reverse = reverse;
function slice(array, start, end) {
    return nativeSlice.call(array, start, end);
}
exports.slice = slice;
function sliceFn(start, end) {
    return function (array) { return nativeSlice.call(array, start, end); };
}
exports.sliceFn = sliceFn;
function take(array, count) {
    return nativeSlice.call(array, 0, count);
}
exports.take = take;
function takeFn(count) {
    return function (array) { return nativeSlice.call(array, 0, count); };
}
exports.takeFn = takeFn;
function drop(array, count) {
    return nativeSlice.call(array, count);
}
exports.drop = drop;
function dropFn(count) {
    return function (array) { return nativeSlice.call(array, count); };
}
exports.dropFn = dropFn;
function takeWhile(array, predicate) {
    var i = 0;
    while (i < array.length && predicate(array[i], i)) {
        ++i;
    }
    return take(array, i);
}
exports.takeWhile = takeWhile;
function takeWhileFn(predicate) {
    return function (array) { return takeWhile(array, predicate); };
}
exports.takeWhileFn = takeWhileFn;
function dropWhile(array, predicate) {
    var i = 0;
    while (i < array.length && predicate(array[i], i)) {
        ++i;
    }
    return drop(array, i);
}
exports.dropWhile = dropWhile;
function dropWhileFn(predicate) {
    return function (array) { return dropWhile(array, predicate); };
}
exports.dropWhileFn = dropWhileFn;
/** @internal This implementation is for internal use only, the exported declaration is above */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.
exports.map = Array.from != null
    ? Array.from // TypeScript 3.2 incorrectly requires this cast to any.
    : function (array, f) { return nativeMap.call(array, f); };
function mapFn(f) {
    return function (array) { return exports.map(array, f); };
}
exports.mapFn = mapFn;
function filter(array, predicate) {
    return nativeFilter.call(array, predicate);
}
exports.filter = filter;
function filterFn(predicate) {
    return function (array) { return filter(array, predicate); };
}
exports.filterFn = filterFn;
function filterFirst(array, predicate) {
    var result = [];
    var i = 0;
    for (; i < array.length; ++i) {
        var element = array[i];
        if (predicate(element, i)) {
            result.push(element);
        }
        else {
            break;
        }
    }
    for (++i; i < array.length; ++i) {
        result.push(array[i]);
    }
    return result;
}
exports.filterFirst = filterFirst;
function filterFirstFn(predicate) {
    return function (array) { return filterFirst(array, predicate); };
}
exports.filterFirstFn = filterFirstFn;
function exclude(array, predicate) {
    return filter(array, function (element, index) { return !predicate(element, index); });
}
exports.exclude = exclude;
function excludeFn(predicate) {
    return function (array) { return exclude(array, predicate); };
}
exports.excludeFn = excludeFn;
function excludeNull(array) {
    return filter(array, nullable_1.isNotNull);
}
exports.excludeNull = excludeNull;
function excludeFirst(array, predicate) {
    return filterFirst(array, function (element, index) { return !predicate(element, index); });
}
exports.excludeFirst = excludeFirst;
function excludeFirstFn(predicate) {
    return function (array) { return excludeFirst(array, predicate); };
}
exports.excludeFirstFn = excludeFirstFn;
function remove(array, value) {
    return exclude(array, function (element) { return element === value; });
}
exports.remove = remove;
function removeFn(value) {
    return function (array) { return remove(array, value); };
}
exports.removeFn = removeFn;
function removeFirst(array, value) {
    return excludeFirst(array, function (element) { return element === value; });
}
exports.removeFirst = removeFirst;
function removeFirstFn(value) {
    return function (array) { return removeFirst(array, value); };
}
exports.removeFirstFn = removeFirstFn;
function fold(array, f, initial) {
    return nativeReduce.call(array, f, initial);
}
exports.fold = fold;
function foldFn(f, initial) {
    return function (array) { return nativeReduce.call(array, f, initial); };
}
exports.foldFn = foldFn;
function fold1(array, f) {
    return nativeReduce.call(array, f);
}
exports.fold1 = fold1;
function fold1Fn(f) {
    return function (array) { return fold1(array, f); };
}
exports.fold1Fn = fold1Fn;
function foldRight(array, f, initial) {
    return nativeReduceRight.call(array, f, initial);
}
exports.foldRight = foldRight;
function foldRightFn(f, initial) {
    return function (array) { return nativeReduceRight.call(array, f, initial); };
}
exports.foldRightFn = foldRightFn;
function foldRight1(array, f) {
    return nativeReduceRight.call(array, f);
}
exports.foldRight1 = foldRight1;
function foldRight1Fn(f) {
    return function (array) { return foldRight1(array, f); };
}
exports.foldRight1Fn = foldRight1Fn;
function foldMap(array, f, m, initial) {
    var accumulator = initial;
    for (var i = 0; i < array.length; ++i) {
        accumulator = f(accumulator, m(array[i], i), i);
    }
    return accumulator;
}
exports.foldMap = foldMap;
function foldMapFn(f, m, initial) {
    return function (array) { return foldMap(array, f, m, initial); };
}
exports.foldMapFn = foldMapFn;
function foldMapRight(array, f, m, initial) {
    var accumulator = initial;
    var length = array.length;
    for (var i = 0; i < array.length; ++i) {
        accumulator = f(accumulator, m(array[length - i], i), i);
    }
    return accumulator;
}
exports.foldMapRight = foldMapRight;
function foldMapRightFn(f, m, initial) {
    return function (array) { return foldMapRight(array, f, m, initial); };
}
exports.foldMapRightFn = foldMapRightFn;
function contains(array, value) {
    return nativeIndexOf.call(array, value) !== -1;
}
exports.contains = contains;
function containsFn(value) {
    return function (array) { return nativeIndexOf.call(array, value) !== -1; };
}
exports.containsFn = containsFn;
function indexOf(array, value) {
    var index = nativeIndexOf.call(array, value);
    return index === -1 ? null : index;
}
exports.indexOf = indexOf;
function indexOfFn(value) {
    return function (array) { return indexOf(array, value); };
}
exports.indexOfFn = indexOfFn;
/** @internal This implementation is for internal use only, the exported declaration is above */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.
exports.findIndex = nativeFindIndex == null
    ? function (array, predicate) {
        for (var i = 0; i < array.length; ++i) {
            if (predicate(array[i], i)) {
                return i;
            }
        }
        return null;
    }
    : function (array, predicate) {
        var index = nativeFindIndex.call(array, predicate);
        return index === -1 ? null : index;
    };
function findIndexFn(predicate) {
    return function (array) { return exports.findIndex(array, predicate); };
}
exports.findIndexFn = findIndexFn;
function find(array, predicate) {
    var index = exports.findIndex(array, predicate);
    return index == null ? null : array[index];
}
exports.find = find;
function findFn(predicate) {
    return function (array) { return find(array, predicate); };
}
exports.findFn = findFn;
function maximum(array, compare) {
    if (compare === void 0) { compare = ordered_1.compare; }
    return internalMaximum(array, compare);
}
exports.maximum = maximum;
function maximumFn(compare) {
    if (compare === void 0) { compare = ordered_1.compare; }
    return function (array) { return internalMaximum(array, compare); };
}
exports.maximumFn = maximumFn;
function internalMaximum(array, compare) {
    if (array.length === 0) {
        return null;
    }
    var result = array[0];
    for (var i = 1; i < array.length; ++i) {
        if (compare(array[i], result) > 0) {
            result = array[i];
        }
    }
    return result;
}
function minimum(array, compare) {
    if (compare === void 0) { compare = ordered_1.compare; }
    return internalMinimum(array, compare);
}
exports.minimum = minimum;
function minimumFn(compare) {
    if (compare === void 0) { compare = ordered_1.compare; }
    return function (array) { return internalMinimum(array, compare); };
}
exports.minimumFn = minimumFn;
function internalMinimum(array, compare) {
    if (array.length === 0) {
        return null;
    }
    var result = array[0];
    for (var i = 1; i < array.length; ++i) {
        if (compare(array[i], result) < 0) {
            result = array[i];
        }
    }
    return result;
}
function sum(array) {
    return fold(array, function (a, b) { return a + b; }, 0);
}
exports.sum = sum;
function product(array) {
    return fold(array, function (a, b) { return a * b; }, 1);
}
exports.product = product;
function and(array) {
    return exports.findIndex(array, function (element) { return !element; }) == null;
}
exports.and = and;
function or(array) {
    return exports.findIndex(array, function (element) { return !!element; }) != null;
}
exports.or = or;
function any(array, predicate) {
    return exports.findIndex(array, predicate) != null;
}
exports.any = any;
function anyFn(predicate) {
    return function (array) { return any(array, predicate); };
}
exports.anyFn = anyFn;
function all(array, predicate) {
    return !any(array, function (element, index) { return !predicate(element, index); });
}
exports.all = all;
function allFn(predicate) {
    return function (array) { return all(array, predicate); };
}
exports.allFn = allFn;
function concat(arrays) {
    return nativeConcat.apply([], exports.map(arrays, coerce));
}
exports.concat = concat;
function prepend(a) {
    return function (b) { return concat([a, b]); };
}
exports.prepend = prepend;
function append(b) {
    return function (a) { return concat([a, b]); };
}
exports.append = append;
function concatMap(array, f) {
    return concat(exports.map(array, f));
}
exports.concatMap = concatMap;
function concatMapFn(f) {
    return function (array) { return concatMap(array, f); };
}
exports.concatMapFn = concatMapFn;
function noneNull(array) {
    return any(array, nullable_1.isNull) ? null : array;
}
exports.noneNull = noneNull;
function scan(array, f, initial) {
    var result = exports.copy({ length: array.length });
    var accumulator = initial;
    for (var i = 0; i < array.length; ++i) {
        result[i] = accumulator = f(accumulator, array[i], i);
    }
    return result;
}
exports.scan = scan;
function scanFn(f, initial) {
    return function (array) { return scan(array, f, initial); };
}
exports.scanFn = scanFn;
function scan1(array, f) {
    if (array.length === 0) {
        return [];
    }
    var accumulator = array[0];
    var result = exports.copy({ 0: accumulator, length: array.length });
    for (var i = 1; i < array.length; ++i) {
        result[i] = accumulator = f(accumulator, array[i], i);
    }
    return result;
}
exports.scan1 = scan1;
function scan1Fn(f) {
    return function (array) { return scan1(array, f); };
}
exports.scan1Fn = scan1Fn;
function scanRight(array, f, initial) {
    var result = exports.copy({ length: array.length });
    var accumulator = initial;
    for (var i = array.length - 1; i >= 0; --i) {
        result[i] = accumulator = f(accumulator, array[i], i);
    }
    return result;
}
exports.scanRight = scanRight;
function scanRightFn(f, initial) {
    return function (array) { return scanRight(array, f, initial); };
}
exports.scanRightFn = scanRightFn;
function scanRight1(array, f) {
    var _a;
    if (array.length === 0) {
        return [];
    }
    var accumulator = array[array.length - 1];
    var result = exports.copy((_a = {}, _a[array.length - 1] = accumulator, _a.length = array.length, _a));
    for (var i = array.length - 2; i >= 0; --i) {
        result[i] = accumulator = f(accumulator, array[i], i);
    }
    return result;
}
exports.scanRight1 = scanRight1;
function scanRight1Fn(f) {
    return function (array) { return scanRight1(array, f); };
}
exports.scanRight1Fn = scanRight1Fn;
function partition(array, predicate) {
    var a = [];
    var b = [];
    for (var i = 0; i < array.length; ++i) {
        if (predicate(array[i], i)) {
            a.push(array[i]);
        }
        else {
            b.push(array[i]);
        }
    }
    return [a, b];
}
exports.partition = partition;
function partitionFn(predicate) {
    return function (array) { return partition(array, predicate); };
}
exports.partitionFn = partitionFn;
function partitionWhile(array, predicate) {
    var i;
    for (i = 0; i < array.length; ++i) {
        if (!predicate(array[i], i)) {
            break;
        }
    }
    return [take(array, i), drop(array, i)];
}
exports.partitionWhile = partitionWhile;
function partitionWhileFn(predicate) {
    return function (array) { return partitionWhile(array, predicate); };
}
exports.partitionWhileFn = partitionWhileFn;
function keyBy(array, f) {
    var result = dictionary_1.dictionary();
    for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        var key = f(element, i);
        var group_1 = result[key] || [];
        group_1.push(element);
        result[key] = group_1;
    }
    return result;
}
exports.keyBy = keyBy;
function keyByFn(f) {
    return function (array) { return keyBy(array, f); };
}
exports.keyByFn = keyByFn;
function keyFirstBy(array, f) {
    var result = dictionary_1.dictionary();
    for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        var key = f(element, i);
        if (!(key in result)) {
            result[key] = element;
        }
    }
    return result;
}
exports.keyFirstBy = keyFirstBy;
function keyFirstByFn(f) {
    return function (array) { return keyFirstBy(array, f); };
}
exports.keyFirstByFn = keyFirstByFn;
function keyLastBy(array, f) {
    var result = dictionary_1.dictionary();
    for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        result[f(element, i)] = element;
    }
    return result;
}
exports.keyLastBy = keyLastBy;
function keyLastByFn(f) {
    return function (array) { return keyLastBy(array, f); };
}
exports.keyLastByFn = keyLastByFn;
function group(array, grouping) {
    if ("identity" in grouping) {
        if (typeof grouping.hash === "function") {
            return exports.groupByIdentityWithHash(array, grouping.identity, grouping.hash);
        }
        else {
            return groupByIdentity(array, grouping.identity);
        }
    }
    else if ("compare" in grouping) {
        if (typeof grouping.hash === "function") {
            return groupByOrderWithHash(array, grouping.compare, grouping.hash);
        }
        else {
            return groupByOrder(array, grouping.compare);
        }
    }
    else if ("equal" in grouping) {
        if (typeof grouping.hash === "function") {
            return groupByEqualityWithHash(array, grouping.equal, grouping.hash);
        }
        else {
            return groupByEquality(array, grouping.equal);
        }
    }
    else {
        return groupByHash(array, grouping.hash);
    }
}
exports.group = group;
function groupFn(grouping) {
    return function (array) { return group(array, grouping); };
}
exports.groupFn = groupFn;
function groupByIdentity(array, identity) {
    return groupByIdentityInternal(array, identity !== null && identity !== void 0 ? identity : (function (element) { return element; }));
}
exports.groupByIdentity = groupByIdentity;
var groupByIdentityInternal = Map == null
    ? function (array, identity) {
        return groupByEquality(array, function (a, b) { return identity(a) === identity(b); });
    }
    : function (array, identity) {
        var _a;
        var groups = [];
        var map = new Map();
        for (var i = 0; i < array.length; ++i) {
            var element = array[i];
            var key = identity(element);
            var group_2 = (_a = map.get(key)) !== null && _a !== void 0 ? _a : [];
            group_2.push(element);
            if (!map.has(key)) {
                groups.push(group_2);
                map.set(key, group_2);
            }
        }
        return groups;
    };
function groupByIdentityFn(identity) {
    return function (array) { return groupByIdentityInternal(array, identity); };
}
exports.groupByIdentityFn = groupByIdentityFn;
function groupByEquality(array, equal) {
    var result = [];
    outer: for (var i = 0; i < array.length; ++i) {
        for (var j = 0; j < result.length; ++j) {
            if (equal(result[j][0], array[i])) {
                result[j].push(array[i]);
                continue outer;
            }
        }
        result.push([array[i]]);
    }
    return result;
}
exports.groupByEquality = groupByEquality;
function groupByEqualityFn(equal) {
    return function (array) { return groupByEquality(array, equal); };
}
exports.groupByEqualityFn = groupByEqualityFn;
function groupByOrder(array, compare) {
    // TODO: This could use a binary tree to be way more efficient
    return groupByEquality(array, function (a, b) { return compare(a, b) === ordered_1.Comparison.equal; });
}
exports.groupByOrder = groupByOrder;
function groupByOrderFn(compare) {
    return function (array) { return groupByOrder(array, compare); };
}
exports.groupByOrderFn = groupByOrderFn;
function groupByHash(array, hash) {
    var groups = dictionary_1.dictionary();
    var result = [];
    for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        var h = hash(element, i);
        if (h in groups) {
            groups[h].push(element); // Cast to any because TypeScript doesn't support symbol indexers yet
        }
        else {
            var group_3 = [element];
            groups[h] = group_3; // Cast to any because TypeScript doesn't support symbol indexers yet
            result.push(group_3);
        }
    }
    return result;
}
exports.groupByHash = groupByHash;
function groupByHashFn(hash) {
    return function (array) { return groupByHash(array, hash); };
}
exports.groupByHashFn = groupByHashFn;
/** @internal This implementation is for internal use only, the exported declaration is above */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.
exports.groupByIdentityWithHash = Map == null
    ? function (array, identity, hash) { return groupByEqualityWithHash(array, function (a, b) { return identity(a) === identity(b); }, hash); }
    : groupByIdentityInternal;
function groupByIdentityWithHashFn(identity, hash) {
    return function (array) { return exports.groupByIdentityWithHash(array, identity, hash); };
}
exports.groupByIdentityWithHashFn = groupByIdentityWithHashFn;
function groupByEqualityWithHash(array, equal, hash) {
    var groups = dictionary_1.dictionary();
    var result = [];
    outer: for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        var h = hash(element, i);
        if (h in groups) {
            var hashGroups = groups[h]; // Cast to any because TypeScript doesn't support symbol indexers yet
            for (var j = 0; j < hashGroups.length; ++j) {
                if (equal(hashGroups[j][0], element)) {
                    hashGroups[j].push(element);
                    continue outer;
                }
            }
            var group_4 = [element];
            hashGroups.push(group_4);
            result.push(group_4);
        }
        else {
            var group_5 = [element];
            groups[h] = [group_5]; // Cast to any because TypeScript doesn't support symbol indexers yet
            result.push(group_5);
        }
    }
    return result;
}
exports.groupByEqualityWithHash = groupByEqualityWithHash;
function groupByEqualityWithHashFn(equal, hash) {
    return function (array) { return groupByEqualityWithHash(array, equal, hash); };
}
exports.groupByEqualityWithHashFn = groupByEqualityWithHashFn;
function groupByOrderWithHash(array, compare, hash) {
    return groupByEqualityWithHash(array, function (a, b) { return compare(a, b) === ordered_1.Comparison.equal; }, hash);
}
exports.groupByOrderWithHash = groupByOrderWithHash;
function groupByOrderWithHashFn(compare, hash) {
    return function (array) { return groupByOrderWithHash(array, compare, hash); };
}
exports.groupByOrderWithHashFn = groupByOrderWithHashFn;
function groupAdjacent(array, grouping) {
    if ("identity" in grouping) {
        return groupAdjacentByIdentity(array, grouping.identity);
    }
    else if ("equal" in grouping) {
        return groupAdjacentByEquality(array, grouping.equal);
    }
    else if ("compare" in grouping) {
        return groupAdjacentByOrder(array, grouping.compare);
    }
    else {
        return groupByHash(array, grouping.hash);
    }
}
exports.groupAdjacent = groupAdjacent;
function groupAdjacentFn(grouping) {
    return function (array) { return groupAdjacent(array, grouping); };
}
exports.groupAdjacentFn = groupAdjacentFn;
function groupAdjacentByIdentity(array, identity) {
    return identity == null
        ? groupAdjacentByEquality(array, function (a, b) { return a === b; })
        : groupAdjacentByEquality(array, function (a, b) { return identity(a) === identity(b); });
}
exports.groupAdjacentByIdentity = groupAdjacentByIdentity;
function groupAdjacentByIdentityFn(identity) {
    return function (array) { return groupAdjacentByEquality(array, function (a, b) { return identity(a) === identity(b); }); };
}
exports.groupAdjacentByIdentityFn = groupAdjacentByIdentityFn;
function groupAdjacentByEquality(array, equal) {
    if (array.length === 0) {
        return [];
    }
    var element = array[0];
    var group = [element];
    var result = [group];
    for (var i = 1; i < array.length; ++i) {
        var prev = element;
        element = array[i];
        if (equal(prev, element)) {
            group.push(element);
        }
        else {
            group = [element];
            result.push(group);
        }
    }
    return result;
}
exports.groupAdjacentByEquality = groupAdjacentByEquality;
function groupAdjacentByEqualityFn(equal) {
    return function (array) { return groupAdjacentByEquality(array, equal); };
}
exports.groupAdjacentByEqualityFn = groupAdjacentByEqualityFn;
function groupAdjacentByOrder(array, compare) {
    return groupAdjacentByEquality(array, function (a, b) { return compare(a, b) === ordered_1.Comparison.equal; });
}
exports.groupAdjacentByOrder = groupAdjacentByOrder;
function groupAdjacentByOrderFn(compare) {
    return function (array) { return groupAdjacentByOrder(array, compare); };
}
exports.groupAdjacentByOrderFn = groupAdjacentByOrderFn;
function groupAdjacentByHash(array, hash) {
    if (array.length === 0) {
        return [];
    }
    var element = array[0];
    var h = hash(element, 0);
    var group = [element];
    var result = [group];
    for (var i = 1; i < array.length; ++i) {
        var element_1 = array[i];
        var h1 = hash(element_1, i);
        if (h === h1) {
            group.push(element_1);
        }
        else {
            h = h1;
            group = [element_1];
            result.push(group);
        }
    }
    return result;
}
exports.groupAdjacentByHash = groupAdjacentByHash;
function groupAdjacentByHashFn(hash) {
    return function (array) { return groupAdjacentByHash(array, hash); };
}
exports.groupAdjacentByHashFn = groupAdjacentByHashFn;
function unique(array, grouping) {
    if ("identity" in grouping) {
        if (typeof grouping.hash === "function") {
            return exports.uniqueByIdentityWithHash(array, grouping.identity, grouping.hash);
        }
        else {
            return uniqueByIdentityInternal(array, grouping.identity);
        }
    }
    else if ("compare" in grouping) {
        if (typeof grouping.hash === "function") {
            return uniqueByOrderWithHash(array, grouping.compare, grouping.hash);
        }
        else {
            return uniqueByOrder(array, grouping.compare);
        }
    }
    else if ("equal" in grouping) {
        if (typeof grouping.hash === "function") {
            return uniqueByEqualityWithHash(array, grouping.equal, grouping.hash);
        }
        else {
            return uniqueByEquality(array, grouping.equal);
        }
    }
    else {
        return uniqueByHash(array, grouping.hash);
    }
}
exports.unique = unique;
function uniqueFn(grouping) {
    return function (array) { return unique(array, grouping); };
}
exports.uniqueFn = uniqueFn;
function uniqueByIdentity(array, identity) {
    return uniqueByIdentityInternal(array, identity !== null && identity !== void 0 ? identity : (function (element) { return element; }));
}
exports.uniqueByIdentity = uniqueByIdentity;
var uniqueByIdentityInternal = Set == null
    ? function (array, identity) {
        return uniqueByEquality(array, function (a, b) { return identity(a) === identity(b); });
    }
    : function (array, identity) {
        var seen = new Set();
        var result = [];
        for (var i = 0; i < array.length; ++i) {
            var element = array[i];
            if (!seen.has(element)) {
                seen.add(element);
                result.push(element);
            }
        }
        return result;
    };
function uniqueByEquality(array, equal) {
    var result = [];
    outer: for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        for (var j = 0; j < result.length; ++j) {
            if (equal(element, result[j])) {
                continue outer;
            }
        }
        result.push(element);
    }
    return result;
}
exports.uniqueByEquality = uniqueByEquality;
function uniqueByEqualityFn(equal) {
    return function (array) { return uniqueByEquality(array, equal); };
}
exports.uniqueByEqualityFn = uniqueByEqualityFn;
function uniqueByOrder(array, compare) {
    return uniqueByEquality(array, function (a, b) { return compare(a, b) === ordered_1.Comparison.equal; });
}
exports.uniqueByOrder = uniqueByOrder;
function uniqueByOrderFn(compare) {
    // TODO: This could use a binary tree to be more efficient
    return function (array) { return uniqueByOrder(array, compare); };
}
exports.uniqueByOrderFn = uniqueByOrderFn;
function uniqueByHash(array, hash) {
    var seen = dictionary_1.dictionary();
    var result = [];
    for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        var h = hash(element, i);
        if (seen[h] == null) {
            // Cast to any because TypeScript doesn't support symbol indexers yet
            seen[h] = true;
            result.push(element);
        }
    }
    return result;
}
exports.uniqueByHash = uniqueByHash;
function uniqueByHashFn(hash) {
    return function (array) { return uniqueByHash(array, hash); };
}
exports.uniqueByHashFn = uniqueByHashFn;
/** @internal This implementation is for internal use only, the exported declaration is above */
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore duplicate identifier: This is the actual implementation, the exported declaration is above.
exports.uniqueByIdentityWithHash = Set == null
    ? function (array, identity, hash) { return uniqueByEqualityWithHash(array, function (a, b) { return identity(a) === identity(b); }, hash); }
    : uniqueByIdentityInternal;
function uniqueByIdentityWithHashFn(identity, hash) {
    return function (array) { return exports.uniqueByIdentityWithHash(array, identity, hash); };
}
exports.uniqueByIdentityWithHashFn = uniqueByIdentityWithHashFn;
function uniqueByEqualityWithHash(array, equal, hash) {
    var seenGroups = dictionary_1.dictionary();
    var result = [];
    outer: for (var i = 0; i < array.length; ++i) {
        var element = array[i];
        var h = hash(element, i);
        var seenGroup = seenGroups[h]; // Cast to any because TypeScript doesn't support symbol indexers yet
        if (seenGroup == null) {
            seenGroups[h] = [element];
            result.push(element);
        }
        else {
            for (var j = 0; j < seenGroup.length; ++j) {
                if (equal(seenGroup[j], element)) {
                    continue outer;
                }
            }
            seenGroup.push(element);
            result.push(element);
        }
    }
    return result;
}
exports.uniqueByEqualityWithHash = uniqueByEqualityWithHash;
function uniqueByEqualityWithHashFn(equal, hash) {
    return function (array) { return uniqueByEqualityWithHash(array, equal, hash); };
}
exports.uniqueByEqualityWithHashFn = uniqueByEqualityWithHashFn;
function uniqueByOrderWithHash(array, compare, hash) {
    return uniqueByEqualityWithHash(array, function (a, b) { return compare(a, b) === ordered_1.Comparison.equal; }, hash);
}
exports.uniqueByOrderWithHash = uniqueByOrderWithHash;
function uniqueByOrderWithHashFn(compare, hash) {
    return function (array) { return uniqueByOrderWithHash(array, compare, hash); };
}
exports.uniqueByOrderWithHashFn = uniqueByOrderWithHashFn;
function uniqueAdjacent(array, grouping) {
    if ("identity" in grouping) {
        return uniqueAdjacentByIdentity(array, grouping.identity);
    }
    else if ("equal" in grouping) {
        return uniqueAdjacentByEquality(array, grouping.equal);
    }
    else if ("compare" in grouping) {
        return uniqueAdjacentByOrder(array, grouping.compare);
    }
    else {
        return uniqueAdjacentByHash(array, grouping.hash);
    }
}
exports.uniqueAdjacent = uniqueAdjacent;
function uniqueAdjacentFn(grouping) {
    return function (array) { return uniqueAdjacent(array, grouping); };
}
exports.uniqueAdjacentFn = uniqueAdjacentFn;
function uniqueAdjacentByIdentity(array, identity) {
    return identity == null
        ? uniqueAdjacentByEquality(array, function (a, b) { return a === b; })
        : uniqueAdjacentByEquality(array, function (a, b) { return identity(a) === identity(b); });
}
exports.uniqueAdjacentByIdentity = uniqueAdjacentByIdentity;
function uniqueAdjacentByIdentityFn(identity) {
    return function (array) { return uniqueAdjacentByIdentity(array, identity); };
}
exports.uniqueAdjacentByIdentityFn = uniqueAdjacentByIdentityFn;
function uniqueAdjacentByEquality(array, equal) {
    if (array.length === 0) {
        return [];
    }
    var element = array[0];
    var result = [element];
    for (var i = 1; i < array.length; ++i) {
        var prev = element;
        element = array[i];
        if (!equal(prev, element)) {
            result.push(element);
        }
    }
    return result;
}
exports.uniqueAdjacentByEquality = uniqueAdjacentByEquality;
function uniqueAdjacentByEqualityFn(equal) {
    return function (array) { return uniqueAdjacentByEquality(array, equal); };
}
exports.uniqueAdjacentByEqualityFn = uniqueAdjacentByEqualityFn;
function uniqueAdjacentByOrder(array, compare) {
    return uniqueAdjacentByEquality(array, function (a, b) { return compare(a, b) === ordered_1.Comparison.equal; });
}
exports.uniqueAdjacentByOrder = uniqueAdjacentByOrder;
function uniqueAdjacentByOrderFn(compare) {
    return function (array) { return uniqueAdjacentByOrder(array, compare); };
}
exports.uniqueAdjacentByOrderFn = uniqueAdjacentByOrderFn;
function uniqueAdjacentByHash(array, hash) {
    if (array.length === 0) {
        return [];
    }
    var element = array[0];
    var h = hash(element, 0);
    var result = [element];
    for (var i = 1; i < array.length; ++i) {
        var element_2 = array[i];
        var h1 = hash(element_2, i);
        if (h !== h1) {
            h = h1;
            result.push(element_2);
        }
    }
    return result;
}
exports.uniqueAdjacentByHash = uniqueAdjacentByHash;
function uniqueAdjacentByHashFn(hash) {
    return function (array) { return uniqueAdjacentByHash(array, hash); };
}
exports.uniqueAdjacentByHashFn = uniqueAdjacentByHashFn;
function shuffle(array) {
    var result = exports.copy(array);
    for (var i = 0; i < array.length; ++i) {
        var j = i + Math.floor(Math.random() * (array.length - i));
        var replacement = result[j];
        result[j] = result[i];
        result[i] = replacement;
    }
    return result;
}
exports.shuffle = shuffle;
function forEach(array, f) {
    for (var i = 0; i < array.length; ++i) {
        f(array[i], i);
    }
    return array;
}
exports.forEach = forEach;
function forEachFn(f) {
    return function (array) { return forEach(array, f); };
}
exports.forEachFn = forEachFn;
//# sourceMappingURL=index.js.map