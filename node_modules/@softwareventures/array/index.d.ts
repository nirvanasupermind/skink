import { Comparator } from "@softwareventures/ordered";
import { Dictionary, Key } from "dictionary-types";
export declare function copy<T>(array: ArrayLike<T>): T[];
export declare function isArray<T = unknown>(value: readonly T[] | unknown): value is readonly T[];
export declare function isArrayLike<T>(value: ArrayLike<T> | unknown): value is ArrayLike<T>;
export declare function coerce<T>(array: ArrayLike<T>): readonly T[];
export declare function head<T>(array: ArrayLike<T>): T | null;
export declare function tail<T>(array: ArrayLike<T>): T[];
export declare function initial<T>(array: ArrayLike<T>): T[];
export declare function last<T>(array: ArrayLike<T>): T | null;
export declare function empty<T>(array: ArrayLike<T>): boolean;
export declare function notEmpty<T>(array: ArrayLike<T>): boolean;
export declare function reverse<T>(array: ArrayLike<T>): T[];
export declare function slice<T>(array: ArrayLike<T>, start?: number, end?: number): T[];
export declare function sliceFn<T>(start?: number, end?: number): (array: ArrayLike<T>) => T[];
export declare function take<T>(array: ArrayLike<T>, count: number): T[];
export declare function takeFn<T>(count: number): (array: ArrayLike<T>) => T[];
export declare function drop<T>(array: ArrayLike<T>, count: number): T[];
export declare function dropFn<T>(count: number): (array: ArrayLike<T>) => T[];
export declare function takeWhile<T, U extends T>(array: ArrayLike<T>, predicate: (element: T, index: number) => element is U): U[];
export declare function takeWhile<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function takeWhileFn<T, U extends T>(predicate: (element: T, index: number) => element is U): (array: ArrayLike<T>) => U[];
export declare function takeWhileFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function dropWhile<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function dropWhileFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function map<T, U>(array: ArrayLike<T>, f: (element: T, index: number) => U): U[];
export declare function mapFn<T, U>(f: (element: T, index: number) => U): (array: ArrayLike<T>) => U[];
export declare function filter<T, U extends T>(array: ArrayLike<T>, predicate: (element: T, index: number) => element is U): U[];
export declare function filter<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function filterFn<T, U extends T>(predicate: (element: T, index: number) => element is U): (array: ArrayLike<T>) => U[];
export declare function filterFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function filterFirst<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function filterFirstFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function exclude<T, U>(array: ArrayLike<T | U>, predicate: (element: T | U) => element is T): U[];
export declare function exclude<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function excludeFn<T, U>(predicate: (element: T | U) => element is T): (array: ArrayLike<T | U>) => T[];
export declare function excludeFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function excludeNull<T>(array: ArrayLike<T | null | undefined>): T[];
export declare function excludeFirst<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T[];
export declare function excludeFirstFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T[];
export declare function remove<T>(array: ArrayLike<T>, value: T): T[];
export declare function removeFn<T>(value: T): (array: ArrayLike<T>) => T[];
export declare function removeFirst<T>(array: ArrayLike<T>, value: T): T[];
export declare function removeFirstFn<T>(value: T): (array: ArrayLike<T>) => T[];
export declare function fold<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U;
export declare function foldFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function fold1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T;
export declare function fold1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T;
export declare function foldRight<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U;
export declare function foldRightFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function foldRight1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T;
export declare function foldRight1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T;
export declare function foldMap<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): U;
export declare function foldMapFn<T, U>(f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function foldMapRight<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): U;
export declare function foldMapRightFn<T, U>(f: (accumulator: U, element: U, index: number) => U, m: (element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U;
export declare function contains<T>(array: ArrayLike<T>, value: T): boolean;
export declare function containsFn<T>(value: T): (array: ArrayLike<T>) => boolean;
export declare function indexOf<T>(array: ArrayLike<T>, value: T): number | null;
export declare function indexOfFn<T>(value: T): (array: ArrayLike<T>) => number | null;
export declare function findIndex<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): number | null;
export declare function findIndexFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => number | null;
export declare function find<T, U extends T>(array: ArrayLike<T>, predicate: (element: T) => element is U): U | null;
export declare function find<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): T | null;
export declare function findFn<T, U extends T>(predicate: (element: T) => element is U): (array: ArrayLike<T>) => U | null;
export declare function findFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => T | null;
export declare function maximum<T extends string | number | boolean>(array: ArrayLike<T>): T | null;
export declare function maximum<T>(array: ArrayLike<T>, compare: Comparator<T>): T | null;
export declare function maximumFn<T extends string | number | boolean>(): (array: ArrayLike<T>) => T | null;
export declare function maximumFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T | null;
export declare function minimum<T extends string | number | boolean>(array: ArrayLike<T>): T | null;
export declare function minimum<T>(array: ArrayLike<T>, compare: Comparator<T>): T | null;
export declare function minimumFn<T extends string | number | boolean>(): (array: ArrayLike<T>) => T | null;
export declare function minimumFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T | null;
export declare function sum(array: ArrayLike<number>): number;
export declare function product(array: ArrayLike<number>): number;
export declare function and(array: ArrayLike<boolean>): boolean;
export declare function or(array: ArrayLike<boolean>): boolean;
export declare function any<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): boolean;
export declare function anyFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => boolean;
export declare function all<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): boolean;
export declare function allFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => boolean;
export declare function concat<T>(arrays: ArrayLike<ArrayLike<T>>): T[];
export declare function prepend<T>(a: ArrayLike<T>): (b: ArrayLike<T>) => T[];
export declare function append<T>(b: ArrayLike<T>): (a: ArrayLike<T>) => T[];
export declare function concatMap<T, U>(array: ArrayLike<T>, f: (element: T, index: number) => ArrayLike<U>): U[];
export declare function concatMapFn<T, U>(f: (element: T, index: number) => ArrayLike<U>): (array: ArrayLike<T>) => U[];
export declare function noneNull<T>(array: ArrayLike<T | null>): ArrayLike<T> | null;
export declare function scan<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U[];
export declare function scanFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U[];
export declare function scan1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T[];
export declare function scan1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T[];
export declare function scanRight<T, U>(array: ArrayLike<T>, f: (accumulator: U, element: T, index: number) => U, initial: U): U[];
export declare function scanRightFn<T, U>(f: (accumulator: U, element: T, index: number) => U, initial: U): (array: ArrayLike<T>) => U[];
export declare function scanRight1<T>(array: ArrayLike<T>, f: (accumulator: T, element: T, index: number) => T): T[];
export declare function scanRight1Fn<T>(f: (accumulator: T, element: T, index: number) => T): (array: ArrayLike<T>) => T[];
export declare function partition<T, U extends T>(array: ArrayLike<T>, predicate: (element: T) => element is U): [U[], Array<Exclude<T, U>>];
export declare function partition<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): [T[], T[]];
export declare function partitionFn<T, U extends T>(predicate: (element: T) => element is U): (array: ArrayLike<T>) => [U[], Array<Exclude<T, U>>];
export declare function partitionFn<T>(predicate: (element: T, index: number) => boolean): (array: ArrayLike<T>) => [T[], T[]];
export declare function partitionWhile<T, U extends T>(array: ArrayLike<T>, predicate: (element: T) => element is U): [U[], T[]];
export declare function partitionWhile<T>(array: ArrayLike<T>, predicate: (element: T, index: number) => boolean): [T[], T[]];
export declare function partitionWhileFn<T, U extends T>(predicate: (element: T) => element is U): (array: readonly T[]) => [U[], T[]];
export declare function partitionWhileFn<T>(predicate: (element: T) => boolean): (array: readonly T[]) => [T[], T[]];
export declare function keyBy<TElement, TKey extends Key>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => TKey): Dictionary<TElement[], TKey>;
export declare function keyByFn<TElement, TKey extends Key>(f: (element: TElement, index: number) => TKey): (array: ArrayLike<TElement>) => Dictionary<TElement[], TKey>;
export declare function keyFirstBy<TElement, TKey extends Key>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => TKey): Dictionary<TElement, TKey>;
export declare function keyFirstByFn<TElement, TKey extends Key>(f: (element: TElement, index: number) => TKey): (array: ArrayLike<TElement>) => Dictionary<TElement, TKey>;
export declare function keyLastBy<TElement, TKey extends Key>(array: ArrayLike<TElement>, f: (element: TElement, index: number) => TKey): Dictionary<TElement, TKey>;
export declare function keyLastByFn<TElement, TKey extends Key>(f: (element: TElement, index: number) => TKey): (array: ArrayLike<TElement>) => Dictionary<TElement, TKey>;
export interface IdentityGrouping<T> {
    readonly identity: (element: T) => unknown;
    readonly hash?: (element: T) => Key;
}
export interface EqualityGrouping<T> {
    readonly equal: (a: T, b: T) => boolean;
    readonly hash?: (element: T, index: number) => Key;
}
export interface OrderedGrouping<T> {
    readonly compare: Comparator<T>;
    readonly hash?: (element: T, index: number) => Key;
}
export interface HashGrouping<T> {
    readonly hash: (element: T, index: number) => Key;
}
export declare type Grouping<T> = IdentityGrouping<T> | EqualityGrouping<T> | OrderedGrouping<T> | HashGrouping<T>;
export declare function group<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[][];
export declare function groupFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[][];
export declare function groupByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[][];
export declare function groupByIdentityFn<T>(identity: (element: T) => unknown): (array: ArrayLike<T>) => T[][];
export declare function groupByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[][];
export declare function groupByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[][];
export declare function groupByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[][];
export declare function groupByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[][];
export declare function groupByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => Key): T[][];
export declare function groupByHashFn<T>(hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[][];
export declare function groupByIdentityWithHash<T>(array: ArrayLike<T>, identity: (element: T) => unknown, hash: (element: T, index: number) => Key): T[];
export declare function groupByIdentityWithHashFn<T>(identity: (element: T) => unknown, hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[][];
export declare function groupByEqualityWithHash<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => Key): T[][];
export declare function groupByEqualityWithHashFn<T>(equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[][];
export declare function groupByOrderWithHash<T>(array: ArrayLike<T>, compare: Comparator<T>, hash: (element: T, index: number) => Key): T[][];
export declare function groupByOrderWithHashFn<T>(compare: Comparator<T>, hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacent<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[][];
export declare function groupAdjacentFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[][];
export declare function groupAdjacentByIdentityFn<T>(identity: (element: T) => unknown): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[][];
export declare function groupAdjacentByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[][];
export declare function groupAdjacentByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[][];
export declare function groupAdjacentByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => Key): T[][];
export declare function groupAdjacentByHashFn<T>(hash: (element: T, index: number) => string): (array: ArrayLike<T>) => T[][];
export declare function unique<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[];
export declare function uniqueFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[];
export declare function uniqueByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[];
export declare function uniqueByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[];
export declare function uniqueByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[];
export declare function uniqueByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => Key): T[];
export declare function uniqueByHashFn<T>(hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[];
export declare function uniqueByIdentityWithHash<T>(array: ArrayLike<T>, identity: (element: T) => unknown, hash: (element: T, index: number) => Key): T[];
export declare function uniqueByIdentityWithHashFn<T>(identity: (element: T) => unknown, hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[];
export declare function uniqueByEqualityWithHash<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => Key): T[];
export declare function uniqueByEqualityWithHashFn<T>(equal: (a: T, b: T) => boolean, hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[];
export declare function uniqueByOrderWithHash<T>(array: ArrayLike<T>, compare: Comparator<T>, hash: (element: T, index: number) => Key): T[];
export declare function uniqueByOrderWithHashFn<T>(compare: Comparator<T>, hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacent<T>(array: ArrayLike<T>, grouping: Grouping<T>): T[];
export declare function uniqueAdjacentFn<T>(grouping: Grouping<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByIdentity<T>(array: ArrayLike<T>, identity?: (element: T) => unknown): T[];
export declare function uniqueAdjacentByIdentityFn<T>(identity: (element: T) => unknown): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByEquality<T>(array: ArrayLike<T>, equal: (a: T, b: T) => boolean): T[];
export declare function uniqueAdjacentByEqualityFn<T>(equal: (a: T, b: T) => boolean): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByOrder<T>(array: ArrayLike<T>, compare: Comparator<T>): T[];
export declare function uniqueAdjacentByOrderFn<T>(compare: Comparator<T>): (array: ArrayLike<T>) => T[];
export declare function uniqueAdjacentByHash<T>(array: ArrayLike<T>, hash: (element: T, index: number) => Key): T[];
export declare function uniqueAdjacentByHashFn<T>(hash: (element: T, index: number) => Key): (array: ArrayLike<T>) => T[];
export declare function shuffle<T>(array: ArrayLike<T>): T[];
export declare function forEach<T>(array: ArrayLike<T>, f: (element: T, index: number) => void): typeof array;
export declare function forEachFn<T>(f: (element: T, index: number) => void): (array: ArrayLike<T>) => typeof array;
