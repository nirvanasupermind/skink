/*
skink Standard Library
Copyright (c) nirvanasupermind
Usage permitted under terms of MIT License
*/
(begin
    /**************************************************/
    /* String functions */
    (module str (begin
        (def abs (x) 
             (if (= (charAt x 0) "-") (slice x 1) x))
        (def sign (x) 
             (if (= (charAt x 0) "-") -1 1))
        (def neg (x) 
             (if (= (charAt x 0) "-") (slice x 1) "-${x}"))
        (def addSign (s x)
            (if (= s -1) (neg x) x))

        (def padStart (x y z) (begin
            (var result x)
            (while (< (len result) z) (begin
                (set result "${y}${result}")
            ))

            result
        ))

        (def reverse (x) (begin
            (var result "")
            (for (var i 0) (< i (len x)) (+= i 1)
                (set result "${(charAt x i)}${result}"))
            result
        ))

        /* Returns true if str1 is smaller than str2. */
        (def isSmaller (str1 str2) (begin
            /* Calculate lengths of both string */
            (var n1 (len str1))
            (var n2 (len str2))
            (var length ((prop Math "max") n1 n2))
            (+= length 2)

            /* Lexicographic comparison */
            (< (padStart str1 "0" length) 
               (padStart str2 "0" length))
        ))
    ))

    /**************************************************/
    /* 
    Immutable arbitrary-precision integers.
    */
    (class BigInteger null (begin
        (def constructor (this s2) (begin
            (var s "${s2}")
            /* extract sign and scale information */
            (var theSign ((prop str "sign") s))
            (set s ((prop str "abs") s))
            (var i 0)
            (while (= (charAt s i) "0")
                (+= i 1))

            (set (prop this "value") (slice s i))
            (set (prop this "sgn") theSign)


            (if (= (prop this "value") "")
                (set (prop this "value") "0") null) 

            /* alias to properties */
            (def value () (prop this "value"))
            (def sgn () (prop this "sgn"))

            /**************************************************/
            /* Core functions */

            /* function toString:
                        convert into String */
            (set (prop this "toString") (lambda () (begin
                (if (= (sgn) -1) "-${(value)}" "${(value)}")
            )))

            /*
            function neg:
                Negation
             */
             (set (prop this "neg") (lambda ()
                (new BigInteger (value) (- (sgn)))))
            
            /* Comparison */
            (set (prop this "compareTo") (lambda (that)
                (switch ((&& (= (prop that "sgn") -1) 
                             (= (prop this "sgn") -1)) 
                        (- (prop (- this) "compareTo") (- that)))
                        ((< (prop this "sgn") (prop that "sgn")) -1)
                        ((> (prop this "sgn") (prop that "sgn")) 1)
                        (else (if ((prop str "isSmaller")) 
                                   (prop this "value")
                                   (prop that "value"))
                                  -1
                                  (if (= this that) 0 1)))))


            (set (prop this "lt") (lambda (that) 
                                          (= ((prop this "compareTo") that) -1)))
            /* function add:
                     Addition */
            (set (prop this "add") (lambda (that) (begin
                (set that (new BigInteger that))
                (var x (clone this))
                (var y (clone that))

                /* Put bigger argument first */
                (if (< x y) (begin
                                (var t x)
                                (set x y)
                                (set y t)
                ))


                /* extract values */
                (var X (prop x "value"))
                (var Y (prop y "value"))
                (var ny (- y))
                
                 /* extract sign and scale information */
                (switch ((= (prop y "sgn") -1) 
                         (if (= (prop x "sgn") 1)
                             (- x ny)
                             null))
                          /* Negative */
                        (else (begin
                            /* 
                            Now it's our main body...
                            It is assumed X and Y are both +ve
                            taken from: 
                                https://www.geeksforgeeks.org/sum-two-large-numbers/ 
                            */
                            
                            (var str1 (prop x "value"))
                            (var str2 (prop y "value"))
                            (if (> (len str1) (len str2)) (begin
                                (var t str1)
                                (set str1 str2)
                                (set str2 t)
                            ))
                            /* Take an empty String for storing result */
                            (var result "")
                            /* Calculate length of both String */
                            (var n1 (len str1))
                            (var n2 (len str2))

                            /* Reverse both of Strings  */
                            (set str1 ((prop str "reverse") str1))
                            (set str2 ((prop str "reverse") str2))
                            (var carry 0)

                            (for (var i 0) (< i n1) (+= i 1) (begin
                                /* Do school mathematics, 
                                   compute sum of  
                                   current digits and carry */
                                (var sum (+ (parseInt (charAt str1 i))
                                            (parseInt (charAt str2 i))))
                                (+= sum carry)
                                (set result "${result}${(% sum 10)}")
                                (set carry (/ sum 10))
                            )) 

                            /*  Add remaining digits of larger number  */
                            (for (var i n1) (< i n2) (+= i 1) (begin
                                (var sum (+ (parseInt (charAt str2 i))
                                            carry))
                                (set result "${result}${(% sum 10)}")
                                (set carry (/ sum 10))
                            )) 

                            /* Add remaining carry   */
                            (if (> carry 0)
                                (set result "${result}${carry}"))

                            /* reverse resultant String  */
                            (set result ((prop str "reverse") result))

                            /* return result */
                            (new BigInteger result)
                        )))
            )))


        ))
    ))
)